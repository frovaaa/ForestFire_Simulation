---
title: "Assignment 1 - Forest Fire Simulation - Probability and Statistics 2023"
author: "Frova Davide"
output:
  html_notebook: default
  word_document: default
  pdf_document: default
  html_document:
    df_print: paged
---

# Notes
- Grid
- Each cell represents a portion of the forest:
  - Unburned
  - Burning
  - Burned
- If adjacent to a burning and unburned: Can ignite with prob `p`
- If unburned can ignite spontaneously with small prob `p_start`
- Bayes:
  - Likelihood of igniting by neighbor = P (Si(t + 1) = burning|Si_neighbors (t) = burning) = p
  - Lieklihood of igniting spontaneous = P (Si(t + 1) = burning) = p_start
- A burning cell transitions into a burned cell in the next time step.
- Burned and unburned cells retain their states unless altered by the above conditions.


# Design the pseudocode for the forest fire model:
## A. Design the initialize_grid function

Develop pseudocode for the initialize grid
function that outputs a m Ã— n grid, where each point represents a portion of the forest. Your map
should include at least one water body (Water), a few patches of dry grass (DryGrass), areas with
dense trees (DenseTrees), and a few initially burning areas (Burning). Label the rest of the areas
as NormalForest. This grid will represent the initial state of the forest before the fire simulation
begins.


<!-- TODO: Add pseudocode -->

```{r}
cell_states <- c(
  "Water", # 1
  "DryGrass", # 2
  "DenseTrees", # 3
  "Burning", # 4
  "NormalForest" # 5
)


grid_rows <- 10
grid_cols <- 10

# Initialize grif function
initialize_grid <- function(rows, cols) {
  grid <- matrix(nrow = rows, ncol = cols)
  for (y in 1:rows) {
    for (x in 1:cols) {
      # Sample from the indexes of the cell_States dictionary
      grid[y, x] <- sample(seq_along(cell_states), 1)
    }
  }

  return(grid)
}

initial_state <- initialize_grid(grid_rows, grid_cols)
initial_state_labels <- sapply(initial_state, function(val) cell_states[val])
```

## B. Design the plot_grid function
Provide pseudocode to visualize the current state
of the grid using different colors for each type of area (e.g., blue for water, green for NormalForest,
red for Burning areas, etc.).

<!-- TODO: Add pseudocode -->

```{r}
plot_grid <- function(forest_grid) {
  cell_states_colors <- c(
    "Water" = "#0000FF", # Blue
    "DryGrass" = "#ADFF2F", # GreenYellow
    "DenseTrees" = "#006400", # DarkGreen
    "Burning" = "#FF0000", # Red
    "NormalForest" = "#008000" # Green
  )

  # Order the colors to match the cell states
  colors <- cell_states_colors[cell_states]

  # Print the image of the grid
  image(forest_grid, col = colors)

  # Add a legend
  # legend("bottom",
  #   legend = names(cell_states_colors),
  #   fill = cell_states_colors, cex = 1, horiz = TRUE
  # )
}

plot_grid(initial_state)
```

## C. Develop the neighbours function
Create pseudocode to identify neighboring cells
of a given point.

<!-- TODO: Add pseudocode 
Initially saved only the coordinates,
now i save state, and coordinates
-->

```{R}
neighbours <- function(forest_grid, cell) {
  x <- cell[1]
  y <- cell[2]

  max_x <- dim(forest_grid)[1]
  max_y <- dim(forest_grid)[2]


  result <- list(
    c(x - 1, y - 1), # Bottom left
    c(x, y - 1), # Bottom center
    c(x + 1, y - 1), # Bottom right
    c(x - 1, y), # Center left
    c(x + 1, y), # Center right
    c(x - 1, y + 1), # Top left
    c(x, y + 1), # Top center
    c(x + 1, y + 1) # Top right
  )

  valid_result <- list()

  for (negh in result) {
    if (negh[1] > 0 && negh[2] > 0 && negh[1] <= max_x && negh[2] <= max_y) {
      negh_obj <- c(
        "state" = forest_grid[negh[1], negh[2]],
        "coords" = c(
          "x" = negh[1],
          "y" = negh[2]
        )
      )

      valid_result <- append(valid_result, list(negh_obj))
    }
  }

  return(valid_result)
}


test_neghs <- neighbours(initial_state, c(1, 1))


test_neghs[[1]]
test_neghs[[1]]["state"]
test_neghs[[1]]["coords.x"]
test_neghs[[1]]["coords.y"]
```

## D. Construct the propagate function
Draft pseudocode to manage fire propagation based on:
- The type of area
- Its current state
- Neighboring cell states.

<!-- TODO: Add pseudocode -->

```{R}
# "Water",          # 1
# "DryGrass",       # 2
# "DenseTrees",     # 3
# "Burning",        # 4
# "NormalForest"    # 5

propagate <- function(cell, neghs) {
  if (cell[["state"]] != 4) {
    print("Not Burning, RETURN")
    return()
  }

  neghs_probs <- sapply(neghs, function(neg) {
    return(
      switch(
        neg[["state"]],
        "1" = 0.0,      # max = 0.0
        "2" = 0.125,    # max = 1.0
        "3" = 0.05,     # max = 0.4
        "4" = 0.0,      # max = 0.0
        "5" = 0.0875    # max = 0.7
      ) + 
    )
  })

  return(neghs_probs)
}

coords <- c(1, 1)

cell <- c(
  "state" = initial_state[coords[1], coords[2]],
  "coords" = c(
    "x" = coords[1],
    "y" = coords[2]
  )
)

neghs <- neighbours(initial_state, c(cell[["coords.x"]], cell[["coords.y"]]))

propagate_result <- propagate(cell, neghs)
```