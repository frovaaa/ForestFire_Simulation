---
title: "Assignment 1 - Forest Fire Simulation - Probability and Statistics 2023"
author: "Frova Davide"
output:
  html_notebook: default
  word_document: default
  pdf_document: default
  html_document:
    df_print: paged
---

# Notes
- Grid
- Each cell represents a portion of the forest:
  - Unburned
  - Burning
  - Burned
- If adjacent to a burning and unburned: Can ignite with prob `p`
- If unburned can ignite spontaneously with small prob `p_start`
- Bayes:
  - Likelihood of igniting by neighbor = P (Si(t + 1) = burning|Si_neighbors (t) = burning) = p
  - Lieklihood of igniting spontaneous = P (Si(t + 1) = burning) = p_start
- A burning cell transitions into a burned cell in the next time step.
- Burned and unburned cells retain their states unless altered by the above conditions.


# Design the pseudocode for the forest fire model:
## A. Design the initialize_grid function

Develop pseudocode for the initialize grid
function that outputs a m Ã— n grid, where each point represents a portion of the forest. Your map
should include at least one water body (Water), a few patches of dry grass (DryGrass), areas with
dense trees (DenseTrees), and a few initially burning areas (Burning). Label the rest of the areas
as NormalForest. This grid will represent the initial state of the forest before the fire simulation
begins.


<!-- TODO: Add pseudocode -->

```{R}
# Install and load the rgl package
if (!require(rgl)) install.packages("rgl")
library(rgl)
```


```{r}
cell_states <- c(
  "Water", # 1
  "DryGrass", # 2
  "DenseTrees", # 3
  "Burning", # 4
  "NormalForest" # 5
)

cell_states_colors <- c(
  "Water" = "#0000FF", # Blue
  "DryGrass" = "#ADFF2F", # GreenYellow
  "DenseTrees" = "#006400", # DarkGreen
  "Burning" = "#FF0000", # Red
  "NormalForest" = "#008000" # Green
)


grid_rows <- 10
grid_cols <- 10

# Initialize grif function
initialize_grid <- function(rows, cols) {
  # Create a list to store the grid
  grid <- list(
    "status" = matrix(nrow = rows, ncol = cols),
    "prob" = matrix(nrow = rows, ncol = cols)
  )

  for (y in 1:rows) {
    for (x in 1:cols) {
      # Sample from the indexes of the cell_states dictionary
      status <- sample(seq_along(cell_states), 1)
      grid$status[y, x] <- status
      grid$prob[y, x] <- 0.0 # Replace with your actual prob calculation
    }
  }

  return(grid)
}

initial_state <- initialize_grid(grid_rows, grid_cols)


# initial_state_labels <- apply(initial_state$status, c(1,2), function(val) cell_states[val])
```

## B. Design the plot_grid function
Provide pseudocode to visualize the current state
of the grid using different colors for each type of area (e.g., blue for water, green for NormalForest,
red for Burning areas, etc.).

<!-- TODO: Add pseudocode -->

```{r}
plot_grid <- function(forest_grid) {
  # I flip the grid for better visualization and consistency with the print of the values
  flipped_grid <- apply(forest_grid, 2, rev)
  transposed_again <- t(flipped_grid)

  # Order the colors to match the cell states
  colors <- cell_states_colors[cell_states]

  # Print the image of the grid
  image(transposed_again, col = colors)

  # Add a legend
  # legend("bottom",
  #   legend = names(cell_states_colors),
  #   fill = cell_states_colors, cex = 1, horiz = TRUE
  # )
}

plot_grid(initial_state$status)
```


```{R}
plot_3D <- function(forest_grid) {
  flipped_grid <- apply(forest_grid$status, 2, rev)
  transposed_status <- t(flipped_grid)

  flipped_probs <- apply(forest_grid$prob, 2, rev)
  transposed_probs <- t(flipped_probs)

  # Create a 3D plot
  x <- 1:ncol(transposed_status)
  y <- 1:nrow(transposed_status)
  z <- transposed_probs
  colors <- cell_states_colors[transposed_status]
  persp3d(x, y, z, col = colors, xlab = "X", ylab = "Y", zlab = "Prob")
}

plot_3D(initial_state)
# plot_3D(next_state)
```

## C. Develop the neighbours function
Create pseudocode to identify neighboring cells
of a given point.

<!-- TODO: Add pseudocode 
Initially saved only the coordinates,
now i save state, and coordinates
-->

```{R}
# Example output:
# [[1]]
#    state coords.x coords.y
#        3        2        1

# [[2]]
#    state coords.x coords.y
#        4        1        2

# [[3]]
#    state coords.x coords.y
#        1        2        2

neighbours <- function(forest_grid, cell) {
  x <- cell[1]
  y <- cell[2]

  max_x <- dim(forest_grid$status)[1]
  max_y <- dim(forest_grid$status)[2]


  result <- list(
    c(x - 1, y - 1), # Bottom left
    c(x, y - 1), # Bottom center
    c(x + 1, y - 1), # Bottom right
    c(x - 1, y), # Center left
    c(x + 1, y), # Center right
    c(x - 1, y + 1), # Top left
    c(x, y + 1), # Top center
    c(x + 1, y + 1) # Top right
  )

  valid_result <- list()

  for (negh in result) {
    if (negh[1] > 0 && negh[2] > 0 && negh[1] <= max_x && negh[2] <= max_y) {
      negh_obj <- c(
        "state" = forest_grid$status[negh[1], negh[2]],
        "coords" = c(
          "x" = negh[1],
          "y" = negh[2]
        )
      )

      valid_result <- append(valid_result, list(negh_obj))
    }
  }

  return(valid_result)
}


# test_neghs <- neighbours(initial_state, c(1, 1))


# test_neghs[[1]]
# test_neghs[[1]]["state"]
# test_neghs[[1]]["coords.x"]
# test_neghs[[1]]["coords.y"]
```

## D. Construct the propagate function
Draft pseudocode to manage fire propagation based on:
- The type of area
- Its current state
- Neighboring cell states.

<!-- TODO: Add pseudocode -->

```{R}
# Example output:
# [1] 0.3 0.0 0.0



# "Water",          # 1
# "DryGrass",       # 2
# "DenseTrees",     # 3
# "Burning",        # 4
# "NormalForest"    # 5

# Cell:
# cell <- c(
#   "state" = 1--5,
#   "coords" = c(
#     "x" = 1,
#     "y" = 1
#   )
# )
propagate <- function(cell, neighbours) {
  if (cell[["state"]] != 4) {
    return(sapply(neighbours, function(val) 0.0))
  }

  neghs_probs <- sapply(neighbours, function(neg) {
    return(
      switch(neg[["state"]],
        "1" = 0.0, # max = 0.0
        "2" = 0.125, # max = 1.0
        "3" = 0.05, # max = 0.4
        "4" = 0.0, # max = 0.0
        "5" = 0.0875 # max = 0.7
      )
    )
  })

  return(neghs_probs)
}

# coords <- c(1, 1)

# cell <- c(
#   "state" = initial_state[coords[1], coords[2]],
#   "coords" = c(
#     "x" = coords[1],
#     "y" = coords[2]
#   )
# )

# neghs <- neighbours(initial_state, c(cell[["coords.x"]], cell[["coords.y"]]))

# propagate_result <- propagate(cell, neghs)
```

## E. Design the update_grid function:
Develop pseudocode to manage fire dynamics
and grid updates using the neighbours and propagate functions.

<!-- TODO: Add pseudocode -->

```{R}
update_grid <- function(forest_grid) {
  for (y in 1:ncol(forest_grid$status)) {
    for (x in 1:nrow(forest_grid$status)) {
      cell_state <- forest_grid$status[x, y]
      # Get the neighbours of the current cell
      neghs <- neighbours(forest_grid = forest_grid["status"], cell = c(x, y))

      propagate_cell <- c(
        "state" = cell_state,
        "coords" = c(
          "x" = x,
          "y" = y
        )
      )
      probs_propagate <- propagate(propagate_cell, neghs)

      for (negIndex in 1:length(neghs)) {
        forest_grid$prob[neghs[[negIndex]][["coords.x"]], neghs[[negIndex]][["coords.y"]]] <-
          forest_grid$prob[neghs[[negIndex]][["coords.x"]], neghs[[negIndex]][["coords.y"]]] + probs_propagate[[negIndex]]
      }


    }
  }

  return(forest_grid)
}


# Probabilities matrix with initial starting values

next_state <- update_grid(initial_state)

# next_state <- update_grid(next_state)

plot_grid(next_state$status)

plot_probs_and_states(next_state)

# plot_3D(next_state)
```

```{R}
plot_probs_and_states <- function(forest_grid) {
  flipped_grid <- apply(forest_grid$status, 2, rev)

  flipped_probs <- apply(forest_grid$prob, 2, rev)

  # Create a blank plot
  plot(1, 1,
    xlim = c(1, ncol(flipped_grid)), ylim = c(1, nrow(flipped_grid)),
    type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n"
  )

  # Draw rectangles for each cell
  for (i in 1:nrow(flipped_grid)) {
    for (j in 1:ncol(flipped_grid)) {
      rect(j - 0.5, i - 0.5, j + 0.5, i + 0.5, col = cell_states_colors[flipped_grid[i, j]])
    }
  }

  # Add probabilities on top of the rectangles
  for (i in 1:nrow(flipped_probs)) {
    for (j in 1:ncol(flipped_probs)) {
      text(j, i, labels = flipped_probs[i, j], cex = 1.5)
    }
  }
}

# plot_probs_and_states(next_state)
```