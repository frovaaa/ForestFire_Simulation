---
title: "Assignment 1 - Forest Fire Simulation - Probability and Statistics 2023"
author: "Frova Davide"
output:
  html_document:
    df_print: paged
  word_document: default
  html_notebook: default
  pdf_document: default
---

# Notes
- Grid
- Each cell represents a portion of the forest:
  - Unburned
  - Burning
  - Burned
- If adjacent to a burning and unburned: Can ignite with prob `p`
- If unburned can ignite spontaneously with small prob `p_start`
- Bayes:
  - Likelihood of igniting by neighbor = P (Si(t + 1) = burning|Si_neighbors (t) = burning) = p
  - Lieklihood of igniting spontaneous = P (Si(t + 1) = burning) = p_start
- A burning cell transitions into a burned cell in the next time step.
- Burned and unburned cells retain their states unless altered by the above conditions.


# Design the pseudocode for the forest fire model:
## A. Design the initialize_grid function

Develop pseudocode for the initialize grid
function that outputs a m Ã— n grid, where each point represents a portion of the forest. Your map
should include at least one water body (Water), a few patches of dry grass (DryGrass), areas with
dense trees (DenseTrees), and a few initially burning areas (Burning). Label the rest of the areas
as NormalForest. This grid will represent the initial state of the forest before the fire simulation
begins.


<!-- TODO: Add pseudocode -->

```{R}
# Install and load the rgl package
if (!require(rgl)) install.packages("rgl")
library(rgl)
```


```{r}
cell_states <- c(
  "Water", # 1
  "DryGrass", # 2
  "DenseTrees", # 3
  "Burning", # 4
  "NormalForest", # 5
  "Burned" # 6
)

cell_states_colors <- c(
  "#0000FF", # Blue / Water
  "#ADFF2F", # GreenYellow / DryGrass
  "#006400", # DarkGreen / DenseTrees
  "#FF0000", # Red / Burning
  "#008000", # Green / NormalForest
  "#A9A9A9" # DarkGray / Burned
)


grid_rows <- 10
grid_cols <- 10

# Initialize grif function
initialize_grid <- function(rows, cols) {
  # Create a list to store the grid
  grid <- list(
    "status" = matrix(nrow = rows, ncol = cols),
    "prob" = matrix(nrow = rows, ncol = cols)
  )

  for (y in 1:rows) {
    for (x in 1:cols) {
      # Sample from the indexes of the cell_states dictionary (without the burned state)
      status <- sample(seq_along(head(cell_states, -1)), 1)
      grid$status[y, x] <- status
      grid$prob[y, x] <- 0.0 # Replace with your actual prob calculation
    }
  }

  return(grid)
}

# initial_state <- initialize_grid(grid_rows, grid_cols)

# initial_state_labels <- apply(initial_state$status, c(1,2), function(val) cell_states[val])
```

## B. Design the plot_grid function
Provide pseudocode to visualize the current state
of the grid using different colors for each type of area (e.g., blue for water, green for NormalForest,
red for Burning areas, etc.).

<!-- TODO: Add pseudocode -->

```{r}
plot_grid <- function(forest_grid) {
  # I flip the grid for better visualization and consistency with the print of the values
  flipped_grid <- apply(forest_grid, 2, rev)
  transposed_again <- t(flipped_grid)

  # Get unique values to only take the colors needed (image will be angry otherwise)
  colors <- sort(unique(as.vector(forest_grid)))
  # Order the colors to match the cell states
  colors <- sapply(colors, function(val) cell_states_colors[val])

  # Print the image of the grid
  image(transposed_again, col = colors)

  # Add a legend
  # legend("bottom",
  #   legend = names(cell_states_colors),
  #   fill = cell_states_colors, cex = 1, horiz = TRUE
  # )
}

# plot_grid(initial_state$status)
```


```{R}
plot_3D <- function(forest_grid) {
  flipped_grid <- apply(forest_grid$status, 2, rev)
  transposed_status <- t(flipped_grid)

  flipped_probs <- apply(forest_grid$prob, 2, rev)
  transposed_probs <- t(flipped_probs)

  # Create a 3D plot
  x <- 1:ncol(transposed_status)
  y <- 1:nrow(transposed_status)
  z <- transposed_probs
  colors <- cell_states_colors[transposed_status]
  persp3d(x, y, z, col = colors, xlab = "X", ylab = "Y", zlab = "Prob")
}

# plot_3D(initial_state)
# plot_3D(next_state)
```

## C. Develop the neighbours function
Create pseudocode to identify neighboring cells
of a given point.

<!-- TODO: Add pseudocode 
Initially saved only the coordinates,
now i save state, and coordinates
-->

```{R}
# Example output:
# [[1]]
#    state coords.x coords.y
#        3        2        1

# [[2]]
#    state coords.x coords.y
#        4        1        2

# [[3]]
#    state coords.x coords.y
#        1        2        2

# forest_grid object
neighbours <- function(forest_grid, cell) {
  x <- cell[1]
  y <- cell[2]

  max_x <- dim(forest_grid$status)[1]
  max_y <- dim(forest_grid$status)[2]


  result <- list(
    c(x - 1, y - 1), # Top left
    c(x, y - 1), # Top center
    c(x + 1, y - 1), # Top right
    c(x - 1, y), # Center left
    c(x + 1, y), # Center right
    c(x - 1, y + 1), # Bottom left
    c(x, y + 1), # Bottom center
    c(x + 1, y + 1) # Bottom right
  )

  valid_result <- list()

  for (negh in result) {
    if (negh[1] > 0 && negh[2] > 0 && negh[1] <= max_x && negh[2] <= max_y) {
      negh_obj <- c(
        "state" = forest_grid$status[negh[2], negh[1]],
        "coords" = c(
          "x" = negh[1],
          "y" = negh[2]
        )
      )

      valid_result <- append(valid_result, list(negh_obj))
    }
  }

  return(valid_result)
}


# test_neghs <- neighbours(initial_state, c(10, 10))


# test_neghs[[1]]
# test_neghs[[1]]["state"]
# test_neghs[[1]]["coords.x"]
# test_neghs[[1]]["coords.y"]
```

## D. Construct the propagate function
Draft pseudocode to manage fire propagation based on:
- The type of area
- Its current state
- Neighboring cell states.

<!-- TODO: Add pseudocode -->

```{R}
# Example output:
# [1] 0.3 0.0 0.0



# "Water",          # 1
# "DryGrass",       # 2
# "DenseTrees",     # 3
# "Burning",        # 4
# "NormalForest"    # 5

# Cell:
# cell <- c(
#   "state" = 1--5,
#   "coords" = c(
#     "x" = 1,
#     "y" = 1
#   )
# )
propagate <- function(cell, neighbours) {
  if (cell[["state"]] != 4) {
    return(sapply(neighbours, function(val) 0.0))
  }

  neghs_probs <- sapply(neighbours, function(neg) {
    return(
      switch(neg[["state"]],
        "1" = 0.0, # max = 0.0
        "2" = 0.125, # max = 1.0
        "3" = 0.05, # max = 0.4
        "4" = 0.0, # max = 0.0
        "5" = 0.0875, # max = 0.7
        "6" = 0.0 # max = 0.0
      )
    )
  })

  return(neghs_probs)
}

# coords <- c(1, 1)

# cell <- c(
#   "state" = initial_state[coords[1], coords[2]],
#   "coords" = c(
#     "x" = coords[1],
#     "y" = coords[2]
#   )
# )

# neghs <- neighbours(initial_state, c(cell[["coords.x"]], cell[["coords.y"]]))

# propagate_result <- propagate(cell, neghs)
```

## E. Design the update_grid function:
Develop pseudocode to manage fire dynamics
and grid updates using the neighbours and propagate functions.

<!-- TODO: Add pseudocode -->

```{R}
# "Water",          # 1
# "DryGrass",       # 2
# "DenseTrees",     # 3
# "Burning",        # 4
# "NormalForest"    # 5
# "Burned"          # 6

update_grid <- function(forest_grid) {
  for (y in 1:ncol(forest_grid$status)) {
    for (x in 1:nrow(forest_grid$status)) {
      # Get the current cell state
      cell_state <- forest_grid$status[y, x]
      cell_prob <- forest_grid$prob[y, x]

      # If the cell could burn, generate a random number and check with its probability
      # if so, set them to burning and reset their prob
      if (cell_state == 2 || cell_state == 3 || cell_state == 5) {
        rand_value <- runif(1)
        if (rand_value <= cell_prob) {
          forest_grid$status[y, x] <- 4
          forest_grid$prob[y, x] <- 0.0

          cell_state <- 4
          cell_prob <- 0.0
        }
      } else if (cell_state == 4) {
        # If the cell is burning, and the random value gets the prob
        # set it to burned and reset its prob, otherwise increase the prob of going out

        rand_value <- runif(1)
        if (rand_value <= cell_prob) {
          forest_grid$status[y, x] <- 6
          forest_grid$prob[y, x] <- 0.0

          cell_state <- 6
          cell_prob <- 0.0
        } else {
          # Increase the probability of going out
          forest_grid$prob[y, x] <- forest_grid$prob[y, x] + 0.3
          cell_prob <- cell_prob + 0.1
        }
      }

      # Get the neighbours of the current cell
      neghs <- neighbours(forest_grid = forest_grid["status"], cell = c(x, y))

      # Create an "object" with the data needed from the propagate function
      propagate_cell <- c(
        "state" = cell_state,
        "coords" = c(
          "x" = x,
          "y" = y
        )
      )

      # Compute the probabilities of the propagate of the neighbours cells
      probs_propagate <- propagate(propagate_cell, neghs)

      # Foraech of the neighbours for which we have the probs. of ignition
      # we sum it to the current prob. values of the forest_grid
      # (Markov Chain) t_n = t_n-1 + something
      for (negIndex in 1:length(neghs)) {
        forest_grid$prob[neghs[[negIndex]][["coords.y"]], neghs[[negIndex]][["coords.x"]]] <-
          forest_grid$prob[neghs[[negIndex]][["coords.y"]], neghs[[negIndex]][["coords.x"]]] + probs_propagate[[negIndex]]
      }
    }
  }

  return(forest_grid)
}


# Probabilities matrix with initial starting values

# next_state <- update_grid(initial_state)
# next_state <- update_grid(next_state)
# plot_probs_and_states(next_state)

# plot_grid(next_state$status)

# plot_probs_and_states(next_state, FALSE)

# plot_3D(next_state)
```

```{R}
plot_probs_and_states <- function(forest_grid, probs = TRUE) {
  flipped_grid <- apply(forest_grid$status, 2, rev)

  flipped_probs <- apply(forest_grid$prob, 2, rev)

  # Create a blank plot
  plot(1, 1,
    xlim = c(1, ncol(flipped_grid)), ylim = c(1, nrow(flipped_grid)),
    type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n"
  )

  # Draw rectangles for each cell
  for (i in 1:nrow(flipped_grid)) {
    for (j in 1:ncol(flipped_grid)) {
      rect(j - 0.5, i - 0.5, j + 0.5, i + 0.5, col = cell_states_colors[flipped_grid[i, j]])
    }
  }

  # Add probabilities on top of the rectangles
  for (i in 1:nrow(flipped_probs)) {
    for (j in 1:ncol(flipped_probs)) {
      text(j, i, labels = ifelse(probs, flipped_probs[i, j], flipped_grid[i, j]), cex = 1.5)
    }
  }
}

# plot_probs_and_states(next_state)
```

```{R}
simulate <- function() {
  # N simulations, until t_max iterations
  t_max <- 10
  N <- 5
  grid_rows <- 20
  grid_cols <- 20

  for (i in 1:N) {
    paste("Simulation", i)
    # Initialize the grid
    forest_grid <- initialize_grid(grid_rows, grid_cols)

    # Plot the initial state
    plot_grid(forest_grid[["status"]])

    # Iterate over the t_max iterations
    for (t in 1:t_max) {
      # Print the current iteration
      paste("Iteration", t)
      # Update the grid
      forest_grid <- update_grid(forest_grid)

      # Plot the grid
      plot_grid(forest_grid[["status"]])

      # Wait 1 second
      Sys.sleep(1)
    }
  }
}

simulate()
```